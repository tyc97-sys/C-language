# 主題4：指標
###### tags: `TA-整理資料`, `ntust-1101`

# 指標

## 指標 Pointer
* 指標這個功能在 C語言裡有著舉足輕重的地位。
* C語言特有的「指標」（Python 並沒有）可以直接透過記憶體映射的方式來控制硬體，這也是為甚麼在寫底層 code 的時候，特別喜歡使用 C/C++。
* 包括 資料結構（陣列／字串／鏈結串列）、系統程式（編譯器／作業系統）、演算法等等都常使用到指標。

不過在正式進入指標前，我們先來看看C語言在記憶體中的配置。 

## 記憶體配置與管理

![](https://i.imgur.com/eCFoW1k.png)

### System
用於儲存一些命令列參數與環境變數，這部分與系統相關。

### Stack
用來儲存函數的 local variables，以及 call function 時需要儲存的資訊，每一次的呼叫函數就會在此區建立一個 stack frame，儲存該次呼叫的所有 variables 和 statements，這樣一來，同一個函數被重複呼叫時就會有不同的 stack frame，不會互相干擾，遞迴就是透過這樣的機制來執行。

### Heap
用於儲存動態配置的變數，例如 C語言中的 malloc 所建立的變數都儲存於此。

> Stack  一般的狀況會從 high address 往 low address 堆疊，而 heap 剛好從相反方向放置。Heap 與 stack 共用同一塊記憶體空間，此區段所使用的空間從配置開始直到使用 free 釋放前都會存在。

### BSS
用來儲存還沒有被初始化的 static variables，這些變數在程式執行之前會被系統初始化成 0 或 null。 
### Data
儲存的是一些已經初始化的 static variables，例如 C語言的 global variables 以及 static variables 都儲存於此。這區段的變數又分為 read-only area 以及 read-write area，read-write area 存放一般變數，資料會隨程式的執行而改變，read-only 則存放固定的 constant。
### Text
又稱 code segment，這裡存放的是可執行的 CPU 指令（instructions，編譯後所產生的 machine code）。這區段通常會放在 heap 或 stack 之後，避免因為 heap, stack 溢位而覆寫 CPU 指令。

## 範疇 Scope

* 變數的範疇又稱為可視性(visibility)，或稱為可作用範圍。
* 指變數可有效使用的範圍，可分為三類：
    1. 區域變數 local variables：某個函式內的變數，作用範圍僅在函式內。
    2. 區塊變數 block variables：某個程式區塊內的變數，作用範圍僅限於區塊內。
    3. 全域變數 global variables：在函示外，程式可在任何地方使用。

### 生命週期 Lifetime

變數的生命週期指的是，變數存在於記憶體內的時間。
* 區域變數 local variables：從宣告開始到函式結束為止。
* 區塊變數 block variables：從宣告開始到區塊結束為止。
* 全域變數 global variables：從程式開始一直到程式結束。

在程式中，變數只是一個代表某個值（value）的符號。我們在執行程式時，必須將變數所代表的值存在記憶體內，才能對其進行操作。
又因為記憶體是有限的，所以我們必須要妥善管理記憶體空間。
C語言在記憶體空間的處理方法有三種：自動（automatic）、靜態（static）與動態（dynamic）。

## 自動記憶體配置

* 區域變數與區塊變數是以自動的方式管理。每當變數被宣告後，就會自動在記憶體中配置適合的空間供其使用；當變數所在的函式或區塊結束時，所配置的記憶體空間就會被釋放。
* 也就是，宣告在main()函式內的變數，是從其宣告開始進行配置，一直到程式結束時，才會被釋放。對於副程式而言，在副程式宣告的變數，也是從宣告開始進行配置，但它們所在的函式結束（或返回時），就會被釋放。
* 在宣告時，如有給定初始值，則依其值填入記憶體內，否則保留該記憶體原有的值。
* 以這種方式使用記憶體的變數又稱為自動變數，每次在其所處的函式或區塊內。

## 靜態記憶體配置

* 在程式編譯時，全域變數就會被配置到一塊記憶體空間，且在程式執行的過程中，所配置的空間將持續保留給這些變數使用，直到程式結束為止。
* 我們將此種方式稱為靜態記憶體配置。
* 除了全域變數外，C語言允許我們在變數宣告時，使用「static」來修飾，將該變數的記憶體空間強制以靜態方式處理。

## 動態記憶體配置

動態記憶體配置，是由我們以「malloc」等指令來取得記憶體空間，並以「free」釋放不再需要的記憶體空間。以此種方式配置的記憶體空間是不會自動被釋放的，如果我們沒有在程式中使用「free」來釋放，則其生命週期將一直持續到程式結束為止。通常都是以指標來存取這些動態配置的記憶體空間，我們必須小心的以指標來操作這些指向動態配置的記憶體空間，假設在程式中，沒有任何指標指向一個動態配置的記憶體空間，那麼該空間將無法被使用也無法被釋放，我們將此現像稱為記憶體洩漏(memory leak)。

### 函式

* C語言提供以下三個有關動態記憶體配置的函式，它們的函式原型定義於「stdlib.h」中：
    1. `void * malloc(unsigned int size)`，配置一塊大小為`size`的記憶體空間，但不進行初始化。
    1. `void * calloc(unsigned int nelem, unsigned int elsize)`，配置nelem個元素，其中每個元素的大小為`elsize`。與`malloc`不同的是，所配置到的空間的內容會被清空，意即其初始值會被設定為0。
    1. `void * realloc(void *prt, unsigned int newSize)`，改變由`ptr`指標所指向的記憶體空間的大小，將其改成`newSize`的大小。


